package web

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/launchrctl/launchr"
	"github.com/launchrctl/launchr/pkg/archive"
)

const (
	versionLatest = "latest"
	repoName      = "launchrctl/web"

	// PkgPath is the plugin module name.
	PkgPath = "github.com/" + repoName
)

// Generate implements [launchr.GeneratePlugin] interface.
func (p *Plugin) Generate(config launchr.GenerateConfig) error {
	launchr.Term().Info().Printfln("Preparing %s plugin assets...", repoName)

	// Download web client assets.
	subdir := "web-plugin"
	webPath := filepath.Join(config.BuildDir, subdir)
	v := getPluginVersion()
	launchr.Log().Debug("web plugin version used in go.mod", "version", v)
	err := downloadGithubRelease(webPath, repoName, v)
	if err != nil {
		return err
	}

	// Prepare the generated plugin with embed assets.
	launchr.Term().Info().Println("Generating web client embed assets go file")
	type templateVars struct {
		CorePkg     string
		Pkg         string
		ClientPath  string
		SwaggerPath string
	}
	tpl := launchr.Template{Tmpl: pluginTemplate, Data: templateVars{
		CorePkg:    launchr.PkgPath,
		Pkg:        PkgPath,
		ClientPath: subdir,
	}}
	err = tpl.WriteFile(filepath.Join(config.BuildDir, "web_assets.gen.go"))
	if err != nil {
		return err
	}

	return nil
}

func downloadGithubRelease(dir string, project string, version string) error {
	// Get release url and download the tarball.
	releaseURL, err := getGithubReleaseDownloadURL(project, version)
	if err != nil {
		return err
	}
	if releaseURL == "" {
		return fmt.Errorf("gen: failed to get release url for %s %s", project, version)
	}
	launchr.Term().Info().Printfln("Using github release assets: %s", releaseURL)
	launchr.Log().Debug("get github release archive stream", "url", releaseURL)
	gzippedStream, err := getFileStreamByURL(releaseURL)
	if err != nil {
		return err
	}
	defer gzippedStream.Close()

	// Unarchive the release.
	launchr.Log().Debug("unarchiving archive from stream", "dir", dir)
	err = os.MkdirAll(dir, 0750)
	if err != nil {
		return err
	}
	err = archive.Untar(gzippedStream, dir, nil)
	if err != nil {
		return err
	}

	return nil
}

func getPluginVersion() string {
	version := launchr.Version()
	branchRelease := regexp.MustCompile(`-0\..*$`)
	for _, dep := range version.Plugins {
		if strings.HasPrefix(dep, PkgPath+" ") {
			// Get version from the string.
			i := strings.IndexRune(dep, ' ')
			if i == -1 {
				panic("incorrect plugin version")
			}
			v := dep[i+1:]
			// 1. Branch releases referenced like `go get repo_url@branch-name` have a version string
			// like `v0.1.2-0.[date]-[commit-hash]`. We don't have artifacts for that, don't break and use latest.
			// 2. During the development inside the repository, go mod returns (devel).
			if len(v) == 0 || v == "(devel)" || branchRelease.MatchString(v) {
				return versionLatest
			}
			return v
		}
	}
	return versionLatest
}

func getGithubReleaseDownloadURL(repo, version string) (string, error) {
	if version != versionLatest {
		version = "tags/" + version
	}
	apiURL := fmt.Sprintf("https://api.github.com/repos/%s/releases/%s", repo, version)
	// Get release information.
	releaseResp, err := http.Get(apiURL) //nolint G107 // The link is generated above.
	if err != nil {
		return "", err
	}
	// Parse release JSON.
	defer releaseResp.Body.Close()
	if releaseResp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("gen: failed to fetch %s (%d)", apiURL, releaseResp.StatusCode)
	}
	body, err := io.ReadAll(releaseResp.Body)
	if err != nil {
		return "", err
	}
	type GithubAPIResponse struct {
		Assets []struct {
			Name        string `json:"name"`
			DownloadURL string `json:"browser_download_url"`
		}
		TarballURL string `json:"tarball_url"`
	}
	var parsedResp GithubAPIResponse
	err = json.Unmarshal(body, &parsedResp)
	if err != nil {
		return "", err
	}
	for _, asset := range parsedResp.Assets {
		if strings.HasSuffix(asset.Name, "tar.gz") {
			return asset.DownloadURL, nil
		}
	}
	return parsedResp.TarballURL, nil
}

func getFileStreamByURL(url string) (io.ReadCloser, error) {
	resp, err := http.Get(url) //nolint G107 // The link is generated above.
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("gen: could not download from the url %s", url)
	}

	// Return the body of the file.
	return resp.Body, err
}

const pluginTemplate = `// Code generated by {{.Pkg}}. DO NOT EDIT.
package main

import (
	"embed"

	core "{{.CorePkg}}"
	web "{{.Pkg}}"
)

//go:embed {{.ClientPath}}/*
var webClientFS embed.FS

func init() {
	web.SetClientAssetsFS(core.MustSubFS(webClientFS, "{{.ClientPath}}"))
}
`
